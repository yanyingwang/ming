#lang scribble/manual


@(require (for-label racket ming)
           scribble/example
           scribble-rainbow-delimiters)
@(define the-eval
         (make-eval-factory '(racket/base racket/list ming/racket/base ming/racket/list)))


@script/rainbow-delimiters*


@title[#:tag "preface"]{序}
@declare-exporting[ming]

@table-of-contents{}

@section{灵感来源}
纵观人类历史，很多有意义的成果往往都不是靠严谨的逻辑推理得来的，而是一时的灵感迸发，先有了结论，然后再去寻找现象去证明结论。

所以有些事情，你不用管他对错有无，感觉对了就要开干。

我大概在2015年的时候，开始使用Emacs编辑器，那个时候知道了LISP语言，决心要学会使用这门编程语言。大概从2018年开始，我开始投入时间到Racket语言的学习上。

也是在2018年的时候，有次出差北京在和同事们的一次交谈中，我谈到说，自己曾经在维基百科上面看到过@hyperlink["https://zh.wikipedia.org/wiki/%E6%A2%B5%E8%AF%AD#%E8%A8%88%E7%AE%97%E8%AA%9E%E8%A8%80%E5%AD%B8" "一些提及"]，说在一些学术研究的边缘领域中，有讨论用梵语来替代英语作为编程语言的宿主语言，原因是英语的词法规则不工整（动词时态变形，名词主谓宾等等的单词变形规则不够严谨），梵语是已知的最为严谨的语言，从语法词态构词规则等等的角度讲。

作为天生的中文使用者，但近代科学起源于西方，一二三次工业革命均发生在西方，编程语言亦起源于英语国家，这导致大量的一手文献资料都是英语写成的，工作和学习中不得不接触英文，这常常让我不禁的去思考中英文的语言差异。

我想或许，梵语之说显然是西方人局限于西方语言（德语、法语、西班牙语、意大利语都算是拉丁语的方言吧）的固有模式所做出的推演。而实际上，中文才是更值得尝试的宿主语言，特别是对LISP来说。

2021年夏，我的这个想法变得越发成熟。2022年夏，我着手了实现。

@smaller{另可见我曾写过的文章：@hyperlink["http://www.yanying.wang/2019/12/%E7%94%B1%E6%B1%89%E8%AF%AD%E7%BC%96%E7%A8%8B%E6%89%80%E6%83%B3%E5%88%B0%E7%9A%84.html" "《由汉语编程所想到的》"]和@hyperlink["http://www.yanying.wang/2020/10/%E6%88%91%E7%9A%84%E4%B8%80%E7%A7%8D%E5%85%B3%E4%BA%8Elisp%E6%96%B9%E8%A8%80%E5%BC%8F%E7%9A%84%E6%B1%89%E8%AF%AD%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9E%84%E6%80%9D.html" "《我的一种关于lisp方言式的汉语编程语言的构思》"]。}

@section{LISP的基本语法规则}
相较于现今主流的编程语言，LISP的语法是极其简单的（称为@hyperlink["https://en.wikipedia.org/wiki/S-expression" "S表达式"]）：
@itemlist[
@item{它首先由括号约定执行优先级；}
@item{然后由每个括号中的第一个字词表示此括号内容的含义（称为@hyperlink["https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95" "前缀表达式"]）。}
]
例如：@code{1+1+1}用S表达式写作@racket[(+ 1 1 1)]，又如：@code{1+2-3}用S表达式写作@racket[(- (+ 1 2) 3)]。

要理解S表达式，好有一个比喻：自然语言说的“我 爱 你”（主谓宾结构），如果采用S表达式说它的话是“(爱 我 你)”（谓主宾结构）。

@section{LISP代码为何难以读懂}
首先，“谓主宾”的排序方式是不符合大家所使用的的自然语言常见的“主谓宾”排序的，这造成了一部分的阅读障碍。

另外，就是因为括号所衍生出来的语法了：

因为S表达式是前缀表达，相当于把“谓词”前置了。但此时的“谓词”却仅仅只是一个简单的谓词，没有清楚明确的表明出“谓词”随后的数据和“谓词”之间的具体关系（谓词之后的数据将被怎样处理）。而这种关系（或者说将被如何处理）也却并不是单纯而统一的，而是根据这个“谓词”的不同而变化的（因其可以被定义和扩展）。而这种变化在无形当中会造成思维上的负担和混乱。

比如@racket[(+ 1 2 3)]表达式的“谓词”是@racket[+]，整个表达式的意思是@racket{1加2再加3}。@linebreak{}
同样@racket[(if 1 2 3)]表达式的“谓词”是@racket[if]，但其意思却是@racket{如果1是真，则返回2，否则返回3}。

@section{如何改进LISP的难读性}
LISP诞生在上世纪五十年代，现今的编程语言相较之，舍弃了S表达式，引入了更多的关键字来替换括号，表达式也大都采用符合自然语言使用习惯的中缀表达。

但LISP的精髓之处就是他的S表达式，舍弃S表达式并不是我要追求的。

所以进而的去想，S表达式的“谓主宾”形式，其中最为重要的其实是“谓语”，一个表达式的关键含义，也均是由首位的“谓语”来阐述的。这个“谓语”能表达和涵盖的意思越多，也就越让人可以更容易的读懂整个表达式的含义。

比如你可以在这个“谓语”里指明“主”“宾”或者更加具体的位置单词的含义。理想情况下，比如这个“谓语”是一个图画，这个图画明确的表达出来了后面字符应如何组合表达，那么此时整个括号里面的内容就会变得异常的容易解读了。

而提到中文就不得不说，汉语的文字，本身就是由图画演变而来的，天然的在阅读和理解上比英文更加有优势。

另外是显而易见的，中文相较于英文，可以用更短的空间表达出更多有意义的含义。@linebreak{}
It's very obvious to notice that comparing to English, Chinese can use less space to express much more meaningful connotations.

据我调查思考，汉语在语法上更加自由，在语素的颗粒度上更加精细，在书写表达上更有上千年的实践和文化积淀（简练的文言文所淬炼出来的汉字含义，古诗词的工整对账所催生出来的同义词反义词，庞大的地区方言所延展出的在使用上的灵活性），另更有近代吸收西方文化后的白话文改革和简体中文、拼音、标点符号的引入。

上所述种种，更加使用人口之众，都让我认为，将LISP的语法寄宿在汉语下，将拥有强大表达力的中文融入在S表达式幽幽的括号中所产生的编程语言，会将人机交互带入另一层境界。

@section{中文化LISP世界一角}
@italic{这部分是我在实现了一部分名语言的代码后又增加出的内容，一并放在此处是为了具体的解释一下上部分结尾处的我所设想的内容：中文化将如何改进LISP的难读性。}

@subsection{make-list和build-list}
我们以两个Racket标准库里面的Procedure：@racket[make-list]和@racket[build-list]为例来尝试阐述所说。

@subsubsection{英文}
从他们的英文名字上，我们很容易得出这两个Procedure都是用来创建“@racket[list]”的（名语言称之为“@racket[链]”）。

@itemlist[
@item{
@examples[#:eval (the-eval) #:label @elem{对于@racket[make-list]有：}
(make-list 3 'foo)
(make-list 6 "foo")
]
很容易明白，它是用来创建一个包含n个相同值的链的。
}
@item{
@examples[#:eval (the-eval) #:label @elem{对于@racket[build-list]有：}
(build-list 5 values) (code:comment "生成一个包含0-4这个5个数的链。")
(build-list 10 values) (code:comment "生成一个包含0-9这个10个数的链。")
(build-list 10 add1) (code:comment "生成一个包含0-9这个10个数的链，并且每一个数都加上1。")
(build-list 10 (lambda (e) (* 2 e))) (code:comment "生成一个包含0-9这个10个数的链，并且每一个数都乘上自身。")
]
@racket[build-list]的行为更加复杂些：它是用来生成一个链，这个链包含从0数起的n个数，并且生成的时候，这些数是可以被做一些附加处理的。
}
]

对于@racket[make-list]和@racket[build-list]这两个Procedure的具体作用，从名字上我们仅仅能看出它是用来创建链的，并不能看出它的其它更具体的作用。

@subsubsection{中文化后}
中文化后，@racket[make-list]叫@racket[复链]，意为链内部的每个元素是重复的；@racket[build-list]叫@racket[序链]，意为链内部的元素是按照一定的顺序排列的。

@itemlist[
@item{第一，显然这两个Procedure的名字有着较原英文更加丰富的含义，这是我上文提到的我所说的中文化的意义；}
@item{第二，古中文即文言文中，字词的词性很弱，或者说是常常有名词活用动词，动词活用名词的用法。故此，“链”这个字是可以被用作动词的，意为创建链、链起来一组数据、将一组数据存在链结构中。总之，字词的表意性因其所处的语境而可以有被活用的留白；}
@item{第三，从整体性的角度讲，和其他Procedure名放在一块，名字显得有更加有规律可循，语言使用者更容易从整体的角度出发获取到更多意义上的理解。}
]


当然你可以说，这其中的“第一”是因为这两个Procedure原本的英文名字起的不好。

但我们更加应该看到的是，这本质上反应的是一种文化上的差异：英文世界里是存在着一种把事情都简单化的趋向的，这是我认为这两个Procedure采用了@litchar{make-list}和@litchar{build-list}的根本原因，我们即使找出更加贴切的英文词汇来作为这两个Procedure的名字，但或许这些词汇在实际的实现上看起来都是不够直观的。

但对中文来讲就不一样了，中文的造词能力更强：支撑中文造词能力强的技术层原因是它的单字表意特性；非技术层原因是它所造出的词是更加容易被接收者所理解的（这可能和它字的表象特性有关）。

@examples[#:eval (the-eval) #:label "中文化后的示例："
(链 'val 'val 'val)
(复链 3 'val)

(链 1 2 3 4 5)
(序链 5 add1)
(序链 5 (入 (n) (复链 n 'val)))
]

@section{设想}
@subsection{如何做}
@itemlist[
@item{Racket语言，编程语言设计和实现的平台，可先用它设计一个方言，并逐步汉化翻译已实现了的内部库。}
@item{在如上的过程中，逐步建立自动化代码翻译工具，以便让更多人更容易的投入到翻译中。}
@item{循环往复，另可在翻译中引入切合汉语文化的有切实意义的新特性和语法糖。}
]

@subsection{释惑}
@itemlist[
@item{名语言的目的是为了探索以汉语的博大精深，兼容并包，是否可以让编程语言以另外一种方式变得更容易被人理解。}
@item{为什么选择LISP/Racket语言实现：第一，我认为LISP的语法特性间接的做了很大程度的留白，这得以让中文可以最大程度的发挥出它的优势。第二，是认为scheme语言的特殊性，其高级抽象形态的实现都可以回溯到最基本的函数定义上，这也得以让人可以循环渐进的替换完其固有的内部英文定义。}
@item{名会秉持实事求是的精神，不会采用通俗的计算机中文中已有的通用翻译作为编程语言关键字，而是在兼顾汉语的古今含义上做出折取选择。故此，其字词的选择不会一味的去追求完全的文言文化，也不会追求完全的白话文化，甚至不会追求完全汉化（西文字母、标点符号所独有的优点不容被忽视）。}
@item{另外我认为，名的实现过程，除去代码上的东西外，会类似于一个汉语地方方言的实现。所谓方言，比如河南话更甚于说是吴语，即是选择了汉语中的部分字词，定义出了自己方言的特殊意义。而名的实现，我认为会类似于这样一个过程，只不过是在选择时，需要兼顾编程和相应的英文词汇而翻译。}
@item{名的其中之重要一目的是为了给汉语编程探索和指明道路。}
]

@subsection{汉语字典索引}
@itemlist[
@item{@url{http://qiyuan.chaziwang.com/}}
@item{@url{https://www.hwxnet.com/}}
@item{@url{https://cidian.qianp.com/}}
]
